<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Finger + Audio Reactive Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
      color: white;
      text-align: center;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      gap: 10px;
    }
    video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;
      z-index: -1;
    }
    canvas {
      display: block;
    }
    #gestureLabel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
  </style>
</head>
<body>

<div id="controls">
  <input type="file" id="audioFile" accept="audio/*">
  <button id="playPauseBtn" disabled>Play Audio</button>
  <button id="stopAudioBtn" disabled>Stop Audio</button>
  <button id="toggleCameraBtn">Start Camera</button>
</div>
<video id="webcam" autoplay playsinline muted></video>
<canvas id="visualizer"></canvas>
<div id="gestureLabel"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
let audioCtx, analyser, source, dataArray, bufferLength;
let audioElement;
let canvas = document.getElementById('visualizer');
let ctx = canvas.getContext('2d');
let videoEl = document.getElementById('webcam');
let gestureLabel = document.getElementById('gestureLabel');
let animationId;
let mediaStream;
let currentGesture = "";
let gestureTimeout;
let cam;
let cameraRunning = false;

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Toggle camera
async function startCamera() {
  mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
  videoEl.srcObject = mediaStream;

  cam = new Camera(videoEl, {
    onFrame: async () => {
      await hands.send({ image: videoEl });
    },
    width: 640,
    height: 480
  });
  cam.start();
  cameraRunning = true;
}

function stopCamera() {
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  cameraRunning = false;
}

document.getElementById('toggleCameraBtn').addEventListener('click', () => {
  if (cameraRunning) {
    stopCamera();
    document.getElementById('toggleCameraBtn').textContent = "Start Camera";
  } else {
    startCamera();
    document.getElementById('toggleCameraBtn').textContent = "Stop Camera";
  }
});

// Load audio
document.getElementById('audioFile').addEventListener('change', function(e) {
  let file = e.target.files[0];
  if (!file) return;
  let audioURL = URL.createObjectURL(file);

  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  audioElement = new Audio();
  audioElement.src = audioURL;
  audioElement.crossOrigin = "anonymous";
  audioElement.loop = true;

  source = audioCtx.createMediaElementSource(audioElement);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);

  source.connect(analyser);
  analyser.connect(audioCtx.destination);

  document.getElementById('playPauseBtn').disabled = false;
  document.getElementById('stopAudioBtn').disabled = false;
});

// Play / Pause
document.getElementById('playPauseBtn').addEventListener('click', () => {
  if (!audioElement) return;
  if (audioElement.paused) {
    audioCtx.resume();
    audioElement.play();
    document.getElementById('playPauseBtn').textContent = "Pause Audio";
    draw();
  } else {
    audioElement.pause();
    document.getElementById('playPauseBtn').textContent = "Play Audio";
  }
});

// Stop Audio
document.getElementById('stopAudioBtn').addEventListener('click', () => {
  if (audioElement) {
    audioElement.pause();
    audioElement.currentTime = 0;
    cancelAnimationFrame(animationId);
    document.getElementById('playPauseBtn').textContent = "Play Audio";
  }
});

// Draw visualizer
function draw() {
  animationId = requestAnimationFrame(draw);
  analyser.getByteFrequencyData(dataArray);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let centerX = canvas.width / 2;
  let centerY = canvas.height / 2;
  let radius = 150;

  ctx.beginPath();
  for (let i = 0; i < bufferLength; i++) {
    let value = dataArray[i];
    let angle = (i / bufferLength) * Math.PI * 2;
    let barLength = value * 0.8;
    let x = centerX + Math.cos(angle) * (radius + barLength);
    let y = centerY + Math.sin(angle) * (radius + barLength);
    ctx.strokeStyle = `hsl(${i * 4}, 100%, 50%)`;
    ctx.moveTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
    ctx.lineTo(x, y);
  }
  ctx.stroke();
}

// MediaPipe hands
const hands = new Hands({
  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});
hands.onResults(onResults);

function onResults(results) {
  if (!results.multiHandLandmarks.length) return;
  let landmarks = results.multiHandLandmarks[0];
  let fingerCount = countFingers(landmarks);
  let gestureName = mapFingersToEffect(fingerCount);
  if (gestureName !== currentGesture) {
    currentGesture = gestureName;
    showGestureLabel(gestureName);
  }
}

function countFingers(landmarks) {
  let count = 0;
  const tips = [8, 12, 16, 20];
  const pip = [6, 10, 14, 18];
  for (let i = 0; i < tips.length; i++) {
    if (landmarks[tips[i]].y < landmarks[pip[i]].y) count++;
  }
  if (landmarks[4].x < landmarks[3].x) count++;
  return count;
}

function mapFingersToEffect(count) {
  switch (count) {
    case 1: return "Effect: Echo";
    case 2: return "Effect: Distortion";
    case 3: return "Effect: Reverb";
    case 4: return "Effect: Filter Sweep";
    case 5: return "Effect: Visual Bloom";
    default: return "Neutral";
  }
}

function showGestureLabel(text) {
  gestureLabel.textContent = text;
  gestureLabel.style.opacity = 1;
  clearTimeout(gestureTimeout);
  gestureTimeout = setTimeout(() => gestureLabel.style.opacity = 0, 2000);
}
</script>
</body>
</html>
