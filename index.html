<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Finger + Audio Reactive Visualizer — Online Ready</title>
  <style>
    :root{--bg:#071022;--panel:#0f1724;--muted:#9aa7c0;--accent:#5eead4}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef6}
    .container{display:grid;grid-template-columns:1fr 360px;gap:12px;padding:12px;height:100%}
    .left{position:relative;border-radius:12px;overflow:hidden;background:#000;box-shadow:0 8px 40px rgba(0,0,0,0.6)}
    video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
    canvas#overlay{position:absolute;left:0;top:0;pointer-events:none;transform:scaleX(-1)}
    canvas#visual{position:absolute;left:0;top:0;pointer-events:none}
    .panel{padding:14px;background:linear-gradient(180deg,var(--panel),#071022);border-radius:12px;color:var(--muted);display:flex;flex-direction:column;gap:10px}
    h1{margin:0;font-size:16px;color:#e6eef6}
    .row{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .small{font-size:13px;color:var(--muted)}
    .pill{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px}
    .btn{background:#0b1320;color:var(--muted);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
    pre{background:#071022;padding:8px;border-radius:8px;max-height:180px;overflow:auto;color:#cfeefe;font-size:13px}
    footer{font-size:12px;color:#7f92a8}
  </style>
</head>
<body>
  <div class="container">
    <div class="left">
      <video id="video" autoplay playsinline></video>
      <canvas id="overlay"></canvas>
      <canvas id="visual"></canvas>
      <!-- Three.js canvas will be injected when enabled -->
      <div id="threeRoot" style="position:absolute;inset:0;pointer-events:none;display:none"></div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h1>Finger + Audio Reactive — Online Ready</h1>
        <div class="small">Client-only • HTTPS required for camera/mic</div>
      </div>

      <div class="row"><div class="small">Gesture:</div><div id="gestureLabel" class="pill">—</div></div>
      <div class="row"><div class="small">RMS (loudness):</div><div id="rmsLabel" class="pill">0</div></div>
      <div class="row"><div class="small">Dominant freq (Hz):</div><div id="freqLabel" class="pill">—</div></div>

      <div class="row">
        <button id="startBtn" class="btn">Start (Camera + Mic)</button>
        <button id="toggleAudio" class="btn">Toggle Mic</button>
      </div>

      <div class="row">
        <div class="small">Mode:</div>
        <select id="modeSelect" class="btn">
          <option value="canvas">Canvas 2D visuals</option>
          <option value="three">Three.js 3D particles</option>
        </select>
      </div>

      <div class="row">
        <div class="small">Calibration:</div>
        <button id="calBtn" class="btn">Calibrate (visual & audio)</button>
      </div>

      <div>
        <div class="small">Gesture→Effect Mapping (edit in code)</div>
        <pre id="mapPreview"></pre>
      </div>

      <div>
        <div class="small">Notes</div>
        <ul style="margin:6px 0 0 18px;color:#9fb0d0">
          <li>Browsers can't access system audio directly. Route system audio into mic or play audio aloud for analysis.</li>
          <li>Deploy to GitHub Pages / Netlify / Vercel for HTTPS and easy online hosting.</li>
        </ul>
      </div>

      <footer>Built with MediaPipe Hands + Web Audio API + Three.js (optional)</footer>
    </div>
  </div>

  <!-- Libs -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
  /* ---------- Configuration & UI ---------- */
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const visual = document.getElementById('visual');
  const overlayCtx = overlay.getContext('2d');
  const visualCtx = visual.getContext('2d');
  const threeRoot = document.getElementById('threeRoot');

  const gestureLabel = document.getElementById('gestureLabel');
  const rmsLabel = document.getElementById('rmsLabel');
  const freqLabel = document.getElementById('freqLabel');
  const startBtn = document.getElementById('startBtn');
  const toggleAudioBtn = document.getElementById('toggleAudio');
  const calBtn = document.getElementById('calBtn');
  const mapPreview = document.getElementById('mapPreview');
  const modeSelect = document.getElementById('modeSelect');

  let cameraInstance = null;
  let audioStream = null;
  let audioCtx = null;
  let analyser = null;
  let dataArray = null;
  let freqData = null;
  let micEnabled = false;

  // Gesture mapping (editable)
  const gestureMap = [
    { gesture:'index',  condition:'loud',  effect:'particle', params:{intensity:1.8, color:'#ff6b6b'} },
    { gesture:'index',  condition:'quiet', effect:'ripple',   params:{size:1.2, color:'#ffd56b'} },
    { gesture:'middle', condition:'quiet', effect:'ripple',   params:{size:0.7, color:'#6be5ff'} },
    { gesture:'middle', condition:'loud',  effect:'particle', params:{intensity:1.0, color:'#7c6bff'} },
    { gesture:'thumbs', condition:'any',   effect:'colorShift',params:{palette:['#5eead4','#ff8fb1','#a78bfa']} },
    { gesture:'pinch',  condition:'any',   effect:'pinchBurst',params:{color:'#fff',scale:1.2} },
    { gesture:'open',   condition:'any',   effect:'softGlow',params:{color:'#7fffd4',strength:0.18} }
  ];
  mapPreview.textContent = JSON.stringify(gestureMap, null, 2);

  /* ---------- Canvas resize helper ---------- */
  function resizeCanvases(){
    overlay.width = visual.width = video.videoWidth || 1280;
    overlay.height = visual.height = video.videoHeight || 720;
    if(window.threeRenderer){ window.threeRenderer.setSize(overlay.width, overlay.height); }
  }
  video.addEventListener('loadeddata', resizeCanvases);
  window.addEventListener('resize', resizeCanvases);

  /* ---------- WebAudio helpers ---------- */
  async function startAudio(){
    try{
      audioStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaStreamSource(audioStream);
      analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048;
      source.connect(analyser);
      dataArray = new Uint8Array(analyser.fftSize);
      freqData = new Uint8Array(analyser.frequencyBinCount);
      micEnabled = true; toggleAudioBtn.textContent = 'Mute Mic';
    }catch(e){console.error('audio start failed',e); alert('Microphone access denied or unavailable');}
  }
  function stopAudio(){ if(audioStream){ audioStream.getTracks().forEach(t=>t.stop()); audioStream=null; } if(audioCtx){ audioCtx.close(); audioCtx=null; } micEnabled=false; toggleAudioBtn.textContent='Unmute Mic'; }
  toggleAudioBtn.addEventListener('click', ()=>{ if(!micEnabled) startAudio(); else stopAudio(); });

  function computeRMS(){ if(!analyser) return 0; analyser.getByteTimeDomainData(dataArray); let sum=0; for(let i=0;i<dataArray.length;i++){ const v=(dataArray[i]-128)/128; sum+=v*v; } return Math.sqrt(sum/dataArray.length); }
  function computeDominantFrequency(){ if(!analyser) return 0; analyser.getByteFrequencyData(freqData); let max=-1, idx=-1; for(let i=0;i<freqData.length;i++){ if(freqData[i]>max){ max=freqData[i]; idx=i; } } const nyquist = (audioCtx && audioCtx.sampleRate) ? audioCtx.sampleRate/2 : 22050; return (idx / freqData.length) * nyquist; }

  /* ---------- MediaPipe Hands setup ---------- */
  const hands = new Hands({ locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
  hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.5 });
  hands.onResults(onHandsResults);

  function startCamera(){ cameraInstance = new Camera(video, { onFrame: async ()=>{ await hands.send({image:video}); }, width:1280, height:720 }); cameraInstance.start(); }

  /* ---------- Gesture detection (extended: pinch, open palm, two-finger pinch) ---------- */
  function detectGestures(lm){ if(!lm) return {index:false,middle:false,thumbs:false,pinch:false,open:false};
    const idxTip=lm[8], idxPip=lm[6]; const midTip=lm[12], midPip=lm[10]; const thumbTip=lm[4], thumbIp=lm[3];
    const indexExtended = idxTip.y + 0.01 < idxPip.y; const middleExtended = midTip.y + 0.01 < midPip.y;
    const thumbUp = (thumbTip.y + 0.03 < thumbIp.y) && (thumbTip.x < lm[5].x + 0.08);
    // pinch: distance between thumb tip and index tip small
    const dx = (thumbTip.x - idxTip.x) * overlay.width; const dy=(thumbTip.y-idxTip.y)*overlay.height; const distThumbIndex = Math.hypot(dx,dy);
    const pinch = distThumbIndex < Math.max(26, overlay.width*0.04);
    // open palm: most fingers extended & spread
    const fingers = [lm[8], lm[12], lm[16], lm[20]]; let extCount=0; for(const f of fingers){ if(f.y + 0.02 < lm[5].y) extCount++; }
    const open = extCount >= 3;
    return { index:indexExtended, middle:middleExtended, thumbs:thumbUp, pinch, open, raw:{idxTip,midTip,thumbTip} };
  }

  /* ---------- Visual primitives (canvas) ---------- */
  const particles=[]; const ripples=[]; let colorShiftIndex=0; let colorShiftPalette=['#5eead4','#ff8fb1','#a78bfa'];
  function spawnParticles(x,y,color='#fff',intensity=1){ const count=Math.round(16*intensity); for(let i=0;i<count;i++){ particles.push({ x,y, vx:(Math.random()-0.5)*6*intensity, vy:(Math.random()-0.5)*6*intensity, life:60+Math.random()*40, r:2+Math.random()*4, color }); } }
  function spawnRipple(x,y,color='#fff',maxSize=100){ ripples.push({ x,y, r:1, maxR:maxSize + Math.random()*maxSize, a:0.9, color }); }

  function drawVisuals(){ visualCtx.clearRect(0,0,visual.width,visual.height);
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; visualCtx.beginPath(); visualCtx.globalAlpha=Math.max(0,p.life/100); visualCtx.fillStyle=p.color; visualCtx.arc(p.x,p.y,p.r,0,Math.PI*2); visualCtx.fill(); if(p.life<=0) particles.splice(i,1); }
    visualCtx.globalAlpha=1.0; for(let i=ripples.length-1;i>=0;i--){ const r=ripples[i]; r.r+=3; r.a*=0.98; visualCtx.beginPath(); visualCtx.lineWidth=3; visualCtx.strokeStyle=r.color; visualCtx.globalAlpha=r.a; visualCtx.arc(r.x,r.y,r.r,0,Math.PI*2); visualCtx.stroke(); if(r.r>r.maxR||r.a<0.02) ripples.splice(i,1); }
  }

  /* ---------- Three.js setup (optional) ---------- */
  function initThree(){
    // basic points particle system that reacts to inputs
    const width = overlay.width, height=overlay.height;
    const scene = new THREE.Scene();
    const camera3 = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000); camera3.position.z = 200;
    const renderer = new THREE.WebGLRenderer({ alpha:true }); renderer.setSize(width,height); renderer.domElement.style.position='absolute'; renderer.domElement.style.inset='0'; threeRoot.innerHTML=''; threeRoot.appendChild(renderer.domElement); threeRoot.style.display='block';
    const geo = new THREE.BufferGeometry(); const count=1200; const pos = new Float32Array(count*3);
    for(let i=0;i<count;i++){ pos[i*3] = (Math.random()-0.5)*width; pos[i*3+1] = (Math.random()-0.5)*height; pos[i*3+2] = (Math.random()-0.5)*200; }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const mat = new THREE.PointsMaterial({ size:3, vertexColors:false, color:0xffffff, transparent:true, opacity:0.9 });
    const points = new THREE.Points(geo, mat); scene.add(points);

    // simple animate closure
    function render(){ requestAnimationFrame(render); renderer.render(scene,camera3); }
    render();
    // expose renderer to window for resize
    window.threeRenderer = renderer; window.threeScene = scene; window.threeCamera = camera3; window.threePoints = points;
  }
  function disposeThree(){ if(window.threeRenderer){ window.threeRenderer.domElement.remove(); delete window.threeRenderer; delete window.threeScene; delete window.threeCamera; delete window.threePoints; threeRoot.style.display='none'; } }

  /* ---------- Main animation loop ---------- */
  function animate(){ requestAnimationFrame(animate); drawVisuals(); if(window.threePoints){ // gentle pulse based on RMS
      const rms = computeRMS(); window.threePoints.material.size = 2 + rms*20; window.threePoints.material.opacity = 0.6 + rms*2; }
  }
  animate();

  /* ---------- Calibration: visual + audio ---------- */
  const calibration = { indexY:null, middleY:null, rmsNeutral:null, done:false };
  calBtn.addEventListener('click', ()=>{ calibration.indexY=null; calibration.middleY=null; calibration.rmsNeutral=null; calibration.done=false; calBtn.textContent='Calibrating... Hold neutral pose'; // capture after 2s
    setTimeout(()=>{ if(calibration.indexY!==null && calibration.rmsNeutral!==null){ calibration.done=true; calBtn.textContent='Calibrated ✓'; } else { calBtn.textContent='Calibration failed — try again'; } }, 2000);
  });

  /* ---------- MediaPipe results handler ---------- */
  function onHandsResults(results){ resizeCanvases(); overlayCtx.clearRect(0,0,overlay.width,overlay.height);
    if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){ const lm = results.multiHandLandmarks[0]; drawConnectors(overlayCtx, lm, HAND_CONNECTIONS, {color:'#6fb3ff', lineWidth:2}); drawLandmarks(overlayCtx, lm, {color:'#a6f0d6', lineWidth:1, radius:4}); const g = detectGestures(lm);
      // calibration capture
      if(!calibration.done && (calibration.indexY===null || calibration.rmsNeutral===null)){
        // use averaged tips (simple) to set neutrals
        calibration.indexY = lm[8].y; calibration.middleY = lm[12].y; calibration.rmsNeutral = computeRMS();
      }

      const rms = computeRMS(); const freq = audioCtx ? Math.round(computeDominantFrequency()) : 0; rmsLabel.textContent = rms.toFixed(3); freqLabel.textContent = freq?freq.toFixed(0)+' Hz':'—';
      const LOUD_THRESHOLD = (calibration.rmsNeutral || 0.02) * 1.8; // adaptive
      const isLoud = rms > LOUD_THRESHOLD ? 'loud' : 'quiet';
      let gestureStr = 'none'; if(g.index) gestureStr='index'; if(g.middle) gestureStr='middle'; if(g.thumbs) gestureStr='thumbs'; if(g.pinch) gestureStr='pinch'; if(g.open) gestureStr='open'; gestureLabel.textContent = gestureStr + ' · ' + isLoud;

      // trigger mapping
      gestureMap.forEach(mapping=>{ if(mapping.gesture !== gestureStr) return; if(mapping.condition !== 'any' && mapping.condition !== isLoud) return; const sx = (()=>{ if(mapping.gesture==='index') return lm[8].x*overlay.width; if(mapping.gesture==='middle') return lm[12].x*overlay.width; if(mapping.gesture==='thumbs') return lm[4].x*overlay.width; if(mapping.gesture==='pinch') return (lm[4].x*0.5 + lm[8].x*0.5)*overlay.width; return overlay.width/2; })(); const sy = (()=>{ if(mapping.gesture==='index') return lm[8].y*overlay.height; if(mapping.gesture==='middle') return lm[12].y*overlay.height; if(mapping.gesture==='thumbs') return lm[4].y*overlay.height; if(mapping.gesture==='pinch') return (lm[4].y*0.5 + lm[8].y*0.5)*overlay.height; return overlay.height/2; })();

        if(mapping.effect==='particle'){ spawnParticles(sx,sy,mapping.params.color || '#fff', mapping.params.intensity || 1); }
        else if(mapping.effect==='ripple'){ spawnRipple(sx,sy,mapping.params.color || '#fff', 60*(mapping.params.size||1)); }
        else if(mapping.effect==='colorShift'){ const pal = mapping.params.palette || colorShiftPalette; colorShiftPalette = pal; const col = pal[(colorShiftIndex++)%pal.length]; visualCtx.save(); visualCtx.globalAlpha = 0.08; visualCtx.fillStyle = col; visualCtx.fillRect(0,0,visual.width,visual.height); visualCtx.restore(); }
        else if(mapping.effect==='pinchBurst'){ spawnParticles(sx,sy,mapping.params.color || '#fff', mapping.params.scale || 1); }
        else if(mapping.effect==='softGlow'){ visualCtx.save(); visualCtx.globalAlpha = mapping.params.strength || 0.12; visualCtx.fillStyle = mapping.params.color || '#fff'; visualCtx.fillRect(0,0,visual.width,visual.height); visualCtx.restore(); }
      });

    } else { gestureLabel.textContent = 'no-hand'; }
  }

  /* ---------- Entry & lifecycle ---------- */
  startBtn.addEventListener('click', async ()=>{ startBtn.disabled=true; startBtn.textContent='Starting…'; try{ await startAudio(); startCamera(); startBtn.textContent='Running'; }catch(e){ console.error(e); startBtn.textContent='Start'; startBtn.disabled=false; } });

  // mode switching to Three.js
  modeSelect.addEventListener('change', (e)=>{ if(e.target.value==='three'){ initThree(); } else { disposeThree(); } });

  // stop camera on unload
  window.addEventListener('beforeunload', ()=>{ try{ if(cameraInstance) cameraInstance.stop(); stopAudio(); disposeThree(); }catch(e){} });

  console.log('Online-ready prototype loaded. Deploy via GitHub Pages / Netlify / Vercel (HTTPS).');
  </script>
</body>
</html>
