<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Finger Audio FX</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    color: white;
    font-family: sans-serif;
  }
  #video {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
  }
  #visualizer {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    pointer-events: none;
  }
  #controls {
    position: fixed;
    top: 10px; left: 10px;
    z-index: 2;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 8px;
  }
  button {
    margin: 4px;
    padding: 6px 12px;
    cursor: pointer;
  }
</style>
</head>
<body>

<video id="video" autoplay muted playsinline></video>
<canvas id="visualizer"></canvas>

<div id="controls">
  <input type="file" id="audioFile" accept="audio/*" />
  <input type="text" id="youtubeUrl" placeholder="YouTube/Spotify link" />
  <button id="loadUrl">Load</button>
  <button id="startBtn">Start Camera + Audio</button>
  <button id="stopBtn">Stop</button>
</div>

<script type="module">
import * as mpHands from "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
import { Camera } from "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

// ====== GLOBALS ======
let audioCtx, sourceNode, analyser, gainNode, reverb, delayNode, lowpass, highpass;
let videoEl = document.getElementById('video');
let canvas = document.getElementById('visualizer');
let ctx = canvas.getContext('2d');
let hands, camera;
let audioBufferSource;
let mediaStream;

// ====== AUDIO SETUP ======
function setupAudioChain(buffer) {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  sourceNode = audioCtx.createBufferSource();
  sourceNode.buffer = buffer;

  analyser = audioCtx.createAnalyser();
  gainNode = audioCtx.createGain();

  // FX nodes
  reverb = audioCtx.createConvolver(); // needs IR file
  delayNode = audioCtx.createDelay(5.0);
  lowpass = audioCtx.createBiquadFilter();
  lowpass.type = "lowpass";
  lowpass.frequency.value = 5000;
  highpass = audioCtx.createBiquadFilter();
  highpass.type = "highpass";
  highpass.frequency.value = 1000;

  // Default chain: source -> analyser -> gain -> destination
  sourceNode.connect(analyser);
  analyser.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  sourceNode.start();
  drawVisualizer();
}

function toggleEffect(effect) {
  // Disconnect all nodes first
  sourceNode.disconnect();
  analyser.disconnect();
  gainNode.disconnect();
  reverb.disconnect();
  delayNode.disconnect();
  lowpass.disconnect();
  highpass.disconnect();

  sourceNode.connect(analyser);
  analyser.connect(gainNode);

  switch(effect) {
    case 'reverb': analyser.connect(reverb).connect(audioCtx.destination); break;
    case 'delay': analyser.connect(delayNode).connect(audioCtx.destination); break;
    case 'lowpass': analyser.connect(lowpass).connect(audioCtx.destination); break;
    case 'highpass': analyser.connect(highpass).connect(audioCtx.destination); break;
    case 'normal': gainNode.connect(audioCtx.destination); break;
    case 'slow': sourceNode.playbackRate.value = 0.8; break;
    case 'fast': sourceNode.playbackRate.value = 1.2; break;
  }
}

// ====== CAMERA & HANDS ======
async function startCamera() {
  hands = new mpHands.Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.5
  });
  hands.onResults(onHands);

  mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
  videoEl.srcObject = mediaStream;

  camera = new Camera(videoEl, {
    onFrame: async () => { await hands.send({ image: videoEl }); },
    width: 640, height: 480
  });
  camera.start();
}

// ====== HAND GESTURE DETECTION ======
function onHands(results) {
  if (!results.multiHandLandmarks.length) return;

  let landmarks = results.multiHandLandmarks[0];

  let pinch = (fingerTip, thumbTip) => {
    let dx = landmarks[fingerTip].x - landmarks[thumbTip].x;
    let dy = landmarks[fingerTip].y - landmarks[thumbTip].y;
    return Math.hypot(dx, dy) < 0.05;
  };

  if (pinch(8,4)) toggleEffect('reverb');     // Index pinch
  else if (pinch(12,4)) toggleEffect('delay'); // Middle pinch
  else if (pinch(16,4)) toggleEffect('lowpass'); // Ring pinch
  else if (pinch(20,4)) toggleEffect('highpass'); // Pinky pinch
  else if (isOpenHand(landmarks)) toggleEffect('normal');
  else if (isClosedFist(landmarks)) toggleEffect('slow');
}

function isOpenHand(lm) {
  return lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y < lm[14].y && lm[20].y < lm[18].y;
}
function isClosedFist(lm) {
  return lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y && lm[20].y > lm[18].y;
}

// ====== VISUALIZER ======
function drawVisualizer() {
  requestAnimationFrame(drawVisualizer);
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let dataArray = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(dataArray);

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  let barWidth = (canvas.width / dataArray.length) * 2.5;
  let x = 0;
  for (let i = 0; i < dataArray.length; i++) {
    let barHeight = dataArray[i];
    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
    x += barWidth + 1;
  }
}

// ====== CONTROLS ======
document.getElementById('startBtn').onclick = () => { startCamera(); };
document.getElementById('stopBtn').onclick = () => {
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  if (audioCtx) audioCtx.close();
};
document.getElementById('audioFile').onchange = (e) => {
  let file = e.target.files[0];
  if (!file) return;
  let reader = new FileReader();
  reader.onload = async function() {
    let buffer = await new AudioContext().decodeAudioData(reader.result);
    setupAudioChain(buffer);
  };
  reader.readAsArrayBuffer(file);
};
document.getElementById('loadUrl').onclick = () => {
  let url = document.getElementById('youtubeUrl').value;
  alert("Direct YouTube/Spotify playback not supported due to CORS â€” download audio or use a file instead.");
};
</script>

</body>
</html>
